import { useCallback, useRef, useEffect, useState } from 'react';
// import { createActor } from 'xstate';
import { applicationMachine } from './machines/applicationMachine';
import { useMachine } from './hooks/useMachine';
import { usePlayerManager } from './hooks/usePlayerManager';
import { SynchronizationService } from './services/syncService';
import { ErrorBoundary, FileUpload, FileList, PlayerGrid, BottomControlBar } from './components';
import type { PlayerType, LottieFile } from './types';

function App() {
  const syncServiceRef = useRef<SynchronizationService | null>(null);
  const playerContainerRefs = useRef<Map<string, HTMLDivElement>>(new Map());
  // Removed playerStatuses and playerAdapters - no longer needed with React DotLottie component
  const [globalZoom, setGlobalZoom] = useState(1);
  const [initializationStats, setInitializationStats] = useState({
    attempts: 0,
    successes: 0,
    failures: 0,
    lastReset: Date.now(),
  });

  const { send, context } = useMachine(applicationMachine);

  const playerManager = usePlayerManager({
    onReady: (playerId: string) => {
      setPlayerStatuses((prev) => new Map(prev.set(playerId, 'ready')));
    },
    onError: (playerId: string) => {
      setPlayerStatuses((prev) => new Map(prev.set(playerId, 'error')));
    },
    onFrameUpdate: (_playerId: string, frame: number, time: number) => {
      // Always update global controls during playback for scrubber movement
      send({
        type: 'UPDATE_FRAME_TIME',
        frame,
        time,
      });
    },
    onComplete: () => {
      // If loop is not enabled, stop playback and update global state
      if (!context.globalControls.loop) {
        send({ type: 'GLOBAL_STOP' });
        getSyncService().broadcastEvent({ type: 'stop', timestamp: Date.now() });
      }
    },
  });

  // Initialize sync service
  const getSyncService = useCallback(() => {
    if (!syncServiceRef.current) {
      syncServiceRef.current = new SynchronizationService({
        threshold: 16.67,
        maxLatency: 50,
        performanceMode: 'quality',
      });
    }
    return syncServiceRef.current;
  }, []);

  const handleFilesSelected = useCallback(
    (files: File[]) => {
      send({ type: 'DROP_FILES', files });
    },
    [send]
  );

  const handleSelectFile = useCallback(
    (file: LottieFile) => {
      send({ type: 'SELECT_FILE', fileId: file.id });
    },
    [send]
  );

  const handleRemoveFile = useCallback(
    (fileId: string) => {
      send({
        type: 'REMOVE_FILE',
        fileId,
      });
    },
    [send]
  );

  const handleAddPlayer = useCallback(
    async (type: PlayerType) => {
      send({ type: 'ADD_PLAYER', playerType: type });
      // Player instance will be created when the container ref is set
    },
    [send]
  );

  const handleRemovePlayer = useCallback(
    (playerId: string) => {
      console.log(`App: Removing player ${playerId}`);
      send({ type: 'REMOVE_PLAYER', playerId });
      playerManager.removePlayer(playerId);
      getSyncService().unregisterPlayer(playerId);

      // Remove adapter reference
      setPlayerAdapters((prev) => {
        const newMap = new Map(prev);
        newMap.delete(playerId);
        return newMap;
      });

      // Remove player status
      setPlayerStatuses((prev) => {
        const newMap = new Map(prev);
        newMap.delete(playerId);
        return newMap;
      });

      // Remove container reference
      playerContainerRefs.current.delete(playerId);
    },
    [send, playerManager, getSyncService]
  );

  const handlePlayerRef = useCallback(
    async (playerId: string, ref: HTMLDivElement | null) => {
      const refTime = performance.now();
      const playerShortId = playerId.slice(-6);
      
      if (ref) {
        console.log(`üéØ [APP-${playerShortId}] Setting container ref at ${refTime.toFixed(2)}ms`);
        console.log(`üèóÔ∏è [APP-${playerShortId}] Container details:`, {
          element: ref.tagName,
          className: ref.className,
          clientDimensions: `${ref.clientWidth}x${ref.clientHeight}`,
          offsetDimensions: `${ref.offsetWidth}x${ref.offsetHeight}`,
          isConnected: ref.isConnected,
          parentElement: ref.parentElement?.tagName,
          childrenCount: ref.children.length
        });
        
        playerContainerRefs.current.set(playerId, ref);
        console.log(`üìç [APP-${playerShortId}] Container ref stored in map (total refs: ${playerContainerRefs.current.size})`);

        // Find the player configuration from state
        console.log(`üîç [APP-${playerShortId}] Searching for player in context.players...`);
        const player = context.players.find((p: any) => p.id === playerId);
        
        console.log(`üìã [APP-${playerShortId}] Player search result:`, {
          found: !!player,
          playerType: player?.type,
          playerConfig: player?.config,
          hasSelectedFile: !!context.selectedFile,
          selectedFileName: context.selectedFile?.name,
          totalPlayersInContext: context.players.length,
          allPlayerIds: context.players.map((p: any) => p.id.slice(-6))
        });
        
        if (player && context.selectedFile) {
          // Skip initialization if player already has an adapter (will be handled by reinitializeAllPlayersWithCurrentFile)
          const hasExistingAdapter = playerAdapters.has(playerId);
          console.log(`üîç [APP-${playerShortId}] Adapter check - hasExistingAdapter: ${hasExistingAdapter}`);
          
          if (hasExistingAdapter) {
            console.log(`‚è≠Ô∏è [APP-${playerShortId}] Player already has adapter, skipping initial creation`);
            console.log(`üìä [APP-${playerShortId}] Current adapter map:`, Array.from(playerAdapters.keys()).map(id => id.slice(-6)));
            return;
          }

          try {
            const creationStartTime = performance.now();
            console.log(`üé¨ [APP-${playerShortId}] Starting player creation at ${creationStartTime.toFixed(2)}ms`);
            console.log(`üé≠ [APP-${playerShortId}] Creation details:`, {
              playerType: player.type,
              fileName: context.selectedFile.name,
              fileId: context.selectedFile.id,
              fileSize: context.selectedFile.file?.size,
              playerConfig: player.config
            });
            
            console.log(`‚è≥ [APP-${playerShortId}] Setting player status to 'loading'`);
            setPlayerStatuses((prev) => new Map(prev.set(playerId, 'loading')));

            // Track attempt
            console.log(`üìä [APP-${playerShortId}] Tracking initialization attempt`);
            setInitializationStats((prev) => ({
              ...prev,
              attempts: prev.attempts + 1,
            }));

            // Add a small staggered delay to prevent simultaneous initialization
            const playerIndex = context.players.findIndex((p: any) => p.id === playerId);
            const staggerDelay = playerIndex * 150; // 150ms staggered delay
            
            console.log(`‚è∞ [APP-${playerShortId}] Player index: ${playerIndex}, staggerDelay: ${staggerDelay}ms`);
            if (staggerDelay > 0) {
              console.log(`‚è∏Ô∏è [APP-${playerShortId}] Applying stagger delay of ${staggerDelay}ms...`);
              await new Promise((resolve) => setTimeout(resolve, staggerDelay));
              console.log(`‚ñ∂Ô∏è [APP-${playerShortId}] Stagger delay completed at ${(performance.now() - creationStartTime).toFixed(2)}ms`);
            }

            console.log(`üè≠ [APP-${playerShortId}] Calling playerManager.createPlayer...`);
            const playerCreateStartTime = performance.now();
            const { adapter } = await playerManager.createPlayer(
              playerId,
              player.type,
              ref,
              context.selectedFile,
              player.config
            );
            const playerCreateEndTime = performance.now();
            console.log(`‚úÖ [APP-${playerShortId}] playerManager.createPlayer completed in ${(playerCreateEndTime - playerCreateStartTime).toFixed(2)}ms`);

            // Register with sync service
            console.log(`üîó [APP-${playerShortId}] Registering with sync service...`);
            const syncRegisterTime = performance.now();
            getSyncService().registerPlayer(playerId, adapter);
            console.log(`‚úÖ [APP-${playerShortId}] Sync service registration completed in ${(performance.now() - syncRegisterTime).toFixed(2)}ms`);

            // Track success
            console.log(`üìà [APP-${playerShortId}] Tracking successful initialization`);
            setInitializationStats((prev) => ({
              ...prev,
              successes: prev.successes + 1,
            }));

            // Store adapter reference for individual controls
            console.log(`üíæ [APP-${playerShortId}] Storing adapter reference`);
            setPlayerAdapters((prev) => new Map(prev.set(playerId, adapter)));

            // Update global controls with first player's info
            if (playerIndex === 0) {
              console.log(`üéÆ [APP-${playerShortId}] First player (index ${playerIndex}) - updating global controls`);
              const controlsStartTime = performance.now();
              const totalFrames = adapter.getTotalFrames();
              const duration = adapter.getDuration();
              
              console.log(`üìä [APP-${playerShortId}] Animation metadata:`, {
                totalFrames,
                duration: duration.toFixed(2),
                frameRate: totalFrames > 0 && duration > 0 ? (totalFrames / duration).toFixed(2) : 'unknown'
              });

              if (totalFrames > 0) {
                console.log(`üì§ [APP-${playerShortId}] Sending UPDATE_GLOBAL_CONTROLS event to state machine`);
                send({
                  type: 'UPDATE_GLOBAL_CONTROLS',
                  totalFrames,
                  duration,
                });
                console.log(`‚úÖ [APP-${playerShortId}] Global controls updated in ${(performance.now() - controlsStartTime).toFixed(2)}ms`);
              } else {
                console.warn(`‚ö†Ô∏è [APP-${playerShortId}] Skipping global controls update - totalFrames is ${totalFrames}`);
              }
            } else {
              console.log(`‚è≠Ô∏è [APP-${playerShortId}] Not first player (index ${playerIndex}) - skipping global controls update`);
            }
            
            const totalCreationTime = performance.now() - creationStartTime;
            console.log(`üéä [APP-${playerShortId}] Player creation COMPLETE in ${totalCreationTime.toFixed(2)}ms`);
          } catch (error) {
            const errorTime = performance.now();
            const errorDuration = errorTime - creationStartTime;
            console.error(`üí• [APP-${playerShortId}] Player creation FAILED after ${errorDuration.toFixed(2)}ms:`, error);
            console.error(`üí• [APP-${playerShortId}] Error details:`, {
              errorType: error instanceof Error ? error.constructor.name : typeof error,
              errorMessage: error instanceof Error ? error.message : String(error),
              errorStack: error instanceof Error ? error.stack : 'No stack available'
            });
            
            console.log(`üö® [APP-${playerShortId}] Setting player status to 'error'`);
            setPlayerStatuses((prev) => new Map(prev.set(playerId, 'error')));

            // Track failure
            console.log(`üìâ [APP-${playerShortId}] Tracking failed initialization`);
            setInitializationStats((prev) => ({
              ...prev,
              failures: prev.failures + 1,
            }));
          }
        }
      } else {
        console.log(`App: Removing container ref for player ${playerId}`);
        playerContainerRefs.current.delete(playerId);
        setPlayerStatuses((prev) => {
          const newMap = new Map(prev);
          newMap.delete(playerId);
          return newMap;
        });
      }
    },
    [context.players, context.selectedFile, playerManager, getSyncService, send]
  );

  // Global control handlers
  const handleGlobalPlay = useCallback(() => {
    send({ type: 'GLOBAL_PLAY' });
    getSyncService().broadcastEvent({ type: 'play', timestamp: Date.now() });
  }, [send, getSyncService]);

  const handleGlobalPause = useCallback(() => {
    send({ type: 'GLOBAL_PAUSE' });
    getSyncService().broadcastEvent({ type: 'pause', timestamp: Date.now() });
  }, [send, getSyncService]);

  const handleGlobalStop = useCallback(() => {
    send({ type: 'GLOBAL_STOP' });
    getSyncService().broadcastEvent({ type: 'stop', timestamp: Date.now() });
  }, [send, getSyncService]);

  const handleGlobalSeek = useCallback(
    (frame: number) => {
      send({ type: 'GLOBAL_SEEK', frame });
      getSyncService().broadcastEvent({
        type: 'seek',
        timestamp: Date.now(),
        data: { frame },
      });
    },
    [send, getSyncService]
  );

  const handleGlobalSpeedChange = useCallback(
    (speed: number) => {
      send({ type: 'GLOBAL_SPEED_CHANGE', speed });
      getSyncService().broadcastEvent({
        type: 'speed-change',
        timestamp: Date.now(),
        data: { speed },
      });
    },
    [send, getSyncService]
  );

  const handleGlobalLoopToggle = useCallback(() => {
    send({ type: 'GLOBAL_LOOP_TOGGLE' });
    getSyncService().broadcastEvent({
      type: 'loop-toggle',
      timestamp: Date.now(),
      data: { loop: !context.globalControls.loop },
    });
  }, [send, context.globalControls.loop, getSyncService]);

  const handleSyncModeToggle = useCallback(() => {
    send({ type: 'TOGGLE_SYNC_MODE' });
  }, [send]);

  const handleGlobalZoomChange = useCallback((zoom: number) => {
    setGlobalZoom(zoom);
  }, []);

  const handleIndividualControl = useCallback((playerId: string, action: string, data?: any) => {
    console.log(`App: Individual control for player ${playerId}: ${action}`, data);
    // Individual controls are handled directly by the PlayerContainer component
    // through the playerAdapter prop. We could add additional logic here if needed.
  }, []);

  const handlePlayerCountChange = useCallback(
    async (count: number) => {
      console.log(`App: Adding player - changing count from ${context.players.length} to ${count}`);
      
      // Only handle adding players now (layout buttons removed)
      if (count > context.players.length) {
        send({ type: 'SET_PLAYER_COUNT', count });
      }
    },
    [send, context.players.length]
  );

  // Helper function to reinitialize all players with the current file (UNUSED - replaced by ensureAllPlayersInitialized)
  const reinitializeAllPlayersWithCurrentFile = useCallback(async () => {
    if (!context.selectedFile || context.players.length === 0) {
      console.log(
        `üö´ App: Skipping reinitialization - selectedFile: ${!!context.selectedFile}, players: ${context.players.length}`
      );
      return;
    }

    console.log(
      `üîß App: Reinitializing all ${context.players.length} players with file: ${context.selectedFile.name}`
    );
    console.log(
      `App: Player containers available:`,
      context.players.map((p: any) => ({
        id: p.id.slice(-6),
        hasContainer: playerContainerRefs.current.has(p.id),
      }))
    );

    // Set all existing players to loading state
    context.players.forEach((player: any) => {
      setPlayerStatuses((prev) => new Map(prev.set(player.id, 'loading')));
    });

    // Reinitialize each player that has a container
    for (let i = 0; i < context.players.length; i++) {
      const player = context.players[i];
      const container = playerContainerRefs.current.get(player.id);

      if (container) {
        try {
          console.log(
            `App: Reinitializing player ${player.id} (${i + 1}/${context.players.length})`
          );

          // Small staggered delay to prevent resource contention
          if (i > 0) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }

          // Clean up existing player instance first
          if (playerAdapters.has(player.id)) {
            try {
              await playerManager.removePlayer(player.id);
              getSyncService().unregisterPlayer(player.id);
              setPlayerAdapters((prev) => {
                const newMap = new Map(prev);
                newMap.delete(player.id);
                return newMap;
              });
            } catch (cleanupError) {
              console.warn(`Error cleaning up player ${player.id}:`, cleanupError);
            }
          }

          // Small delay for cleanup to complete
          await new Promise((resolve) => setTimeout(resolve, 50));

          // Create new player instance
          const { adapter } = await playerManager.createPlayer(
            player.id,
            player.type,
            container,
            context.selectedFile!,
            player.config
          );

          // Register with sync service
          getSyncService().registerPlayer(player.id, adapter);
          setPlayerAdapters((prev) => new Map(prev.set(player.id, adapter)));

          // Update global controls with first player's info
          if (i === 0) {
            const totalFrames = adapter.getTotalFrames();
            const duration = adapter.getDuration();
            if (totalFrames > 0) {
              send({
                type: 'UPDATE_GLOBAL_CONTROLS',
                totalFrames,
                duration,
              });
            }
          }

          console.log(`App: Successfully reinitialized player ${player.id}`);
        } catch (error) {
          console.error(`App: Failed to reinitialize player ${player.id}:`, error);
          setPlayerStatuses((prev) => new Map(prev.set(player.id, 'error')));
        }
      }
    }
  }, [context.selectedFile, context.players, playerManager, getSyncService, playerAdapters, send]);

  // Helper function to ensure all players are initialized (without destroying existing ones)
  const ensureAllPlayersInitialized = useCallback(async () => {
    const ensureStartTime = performance.now();
    const playersToCheck = context.players.length;
    const selectedFileName = context.selectedFile?.name;
    
    console.log(`üöÄ [ENSURE] Starting ensureAllPlayersInitialized at ${ensureStartTime.toFixed(2)}ms`);
    console.log(`üìä [ENSURE] Initialization status:`, {
      totalPlayers: playersToCheck,
      selectedFile: selectedFileName,
      containerRefs: playerContainerRefs.current.size,
      playerAdapters: playerAdapters.size,
      playerStatuses: Array.from(playerStatuses.entries()).map(([id, status]) => `${id.slice(-6)}:${status}`)
    });
    
    if (!context.selectedFile || context.players.length === 0) {
      console.log(`üö´ [ENSURE] Skipping initialization check - selectedFile: ${!!context.selectedFile}, players: ${context.players.length}`);
      return;
    }

    console.log(`üîç [ENSURE] Checking initialization status for ${context.players.length} players`);

    for (let i = 0; i < context.players.length; i++) {
      const player = context.players[i];
      const container = playerContainerRefs.current.get(player.id);
      const hasAdapter = playerAdapters.has(player.id);

      console.log(
        `Player ${player.id.slice(-6)}: hasContainer=${!!container}, hasAdapter=${hasAdapter}`
      );

      // If player has container but no adapter, initialize it
      if (container && !hasAdapter) {
        try {
          console.log(
            `üÜï App: Initializing player ${player.id.slice(-6)} that was missing adapter`
          );
          setPlayerStatuses((prev) => new Map(prev.set(player.id, 'loading')));

          // Small delay between players
          if (i > 0) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }

          const { adapter } = await playerManager.createPlayer(
            player.id,
            player.type,
            container,
            context.selectedFile!,
            player.config
          );

          // Register with sync service
          getSyncService().registerPlayer(player.id, adapter);
          setPlayerAdapters((prev) => new Map(prev.set(player.id, adapter)));

          // Update global controls with first player's info
          if (i === 0) {
            const totalFrames = adapter.getTotalFrames();
            const duration = adapter.getDuration();
            if (totalFrames > 0) {
              send({
                type: 'UPDATE_GLOBAL_CONTROLS',
                totalFrames,
                duration,
              });
            }
          }

          console.log(`‚úÖ App: Successfully initialized player ${player.id.slice(-6)}`);
        } catch (error) {
          console.error(`‚ùå App: Failed to initialize player ${player.id.slice(-6)}:`, error);
          setPlayerStatuses((prev) => new Map(prev.set(player.id, 'error')));
        }
      } else if (container && hasAdapter) {
        console.log(`‚úÖ Player ${player.id.slice(-6)} already properly initialized`);
      } else if (!container) {
        console.log(`‚è≥ Player ${player.id.slice(-6)} waiting for container`);
      }
    }
  }, [context.selectedFile, context.players, playerManager, getSyncService, playerAdapters, send]);

  // Track the previous selected file to avoid infinite loops
  const prevSelectedFileRef = useRef<LottieFile | null>(null);

  // Track previous player count to detect when count increases
  const prevPlayerCountRef = useRef<number>(context.players.length);

  // Effect to handle player count increases - ensure new players get initialized
  useEffect(() => {
    const currentPlayerCount = context.players.length;
    const previousPlayerCount = prevPlayerCountRef.current;

    console.log(
      `App: Player count effect - current: ${currentPlayerCount}, previous: ${previousPlayerCount}, hasFile: ${!!context.selectedFile}`
    );
    console.log('DEBUG: Player count effect state:', {
      playersLength: context.players.length,
      selectedFile: context.selectedFile?.name,
      playerAdaptersSize: playerAdapters.size,
      playerIds: context.players.map(p => p.id.slice(-6)),
      prevSelectedFile: prevSelectedFileRef.current?.name
    });

    // Check if player count increased and we have a selected file
    if (
      currentPlayerCount > previousPlayerCount &&
      context.selectedFile &&
      currentPlayerCount > 0
    ) {
      console.log(
        `üîÑ App: Player count increased from ${previousPlayerCount} to ${currentPlayerCount}, will ensure all players have animations`
      );
      console.log(
        `App: Current players:`,
        context.players.map((p: any) => ({ id: p.id.slice(-6), type: p.type }))
      );
      console.log(
        `App: Current adapters:`,
        Array.from(playerAdapters.keys()).map((id) => id.slice(-6))
      );

      // Small delay to ensure all player containers are ready, then check which players need initialization
      const checkTimer = setTimeout(async () => {
        try {
          console.log(`üöÄ App: Checking which players need initialization...`);
          await ensureAllPlayersInitialized();
          console.log(`‚úÖ App: Player initialization check completed`);
        } catch (error) {
          console.error('‚ùå Error during player initialization check:', error);
        }
      }, 300);

      // Update the ref
      prevPlayerCountRef.current = currentPlayerCount;

      return () => clearTimeout(checkTimer);
    } else {
      // Just update the ref for other cases
      prevPlayerCountRef.current = currentPlayerCount;
    }
  }, [
    context.players.length,
    context.selectedFile,
    context.players,
    playerAdapters,
    ensureAllPlayersInitialized,
  ]);

  // Effect to recreate players when selected file changes
  useEffect(() => {
    if (context.selectedFile && context.players.length > 0) {
      // Only recreate if the file actually changed
      console.log('DEBUG: File selection check:', {
        prevFileId: prevSelectedFileRef.current?.id,
        prevFileName: prevSelectedFileRef.current?.name,
        newFileId: context.selectedFile.id,
        newFileName: context.selectedFile.name,
        isFirstSelection: prevSelectedFileRef.current === null,
        idsMatch: prevSelectedFileRef.current?.id === context.selectedFile.id,
        willRecreate: prevSelectedFileRef.current?.id !== context.selectedFile.id
      });
      
      if (prevSelectedFileRef.current?.id !== context.selectedFile.id) {
        // If this is the first file selection and players already exist, don't recreate
        if (prevSelectedFileRef.current === null && context.players.length > 0) {
          console.log('DEBUG: First file selection with existing players - skipping recreation to avoid race condition');
          prevSelectedFileRef.current = context.selectedFile;
          return;
        }
        
        console.log(
          `Selected file changed from "${prevSelectedFileRef.current?.name}" to "${context.selectedFile.name}", recreating players...`
        );
        prevSelectedFileRef.current = context.selectedFile;

        // Improved async recreation with better error handling
        const recreatePlayersForNewFile = async () => {
          const currentFile = context.selectedFile;

          // Set all players to loading state immediately
          context.players.forEach((player: any) => {
            setPlayerStatuses((prev) => new Map(prev.set(player.id, 'loading')));
          });

          // Clean up existing players in parallel (faster cleanup)
          const cleanupPromises = context.players.map(async (player: any) => {
            try {
              console.log(`Cleaning up player ${player.id}`);
              await playerManager.removePlayer(player.id);
              getSyncService().unregisterPlayer(player.id);
              setPlayerAdapters((prev) => {
                const newMap = new Map(prev);
                newMap.delete(player.id);
                return newMap;
              });
            } catch (error) {
              console.error(`Error cleaning up player ${player.id}:`, error);
            }
          });

          await Promise.all(cleanupPromises);

          // Small delay to ensure all cleanup completes
          await new Promise((resolve) => setTimeout(resolve, 150));

          // Check if file is still current (user might have switched files while cleanup was happening)
          if (currentFile.id !== context.selectedFile?.id) {
            console.log('File changed during cleanup, aborting recreation');
            return;
          }

          // Create new players sequentially to avoid resource contention
          for (let i = 0; i < context.players.length; i++) {
            const player = context.players[i];
            const container = playerContainerRefs.current.get(player.id);

            if (container && currentFile.id === context.selectedFile?.id) {
              try {
                console.log(
                  `Recreating player ${player.id} (${i + 1}/${context.players.length}) with file: ${currentFile.name}`
                );

                // Small staggered delay to prevent simultaneous resource access
                if (i > 0) {
                  await new Promise((resolve) => setTimeout(resolve, 100));
                }

                const { adapter } = await playerManager.createPlayer(
                  player.id,
                  player.type,
                  container,
                  currentFile,
                  player.config
                );

                // Only proceed if file is still current
                if (currentFile.id === context.selectedFile?.id) {
                  getSyncService().registerPlayer(player.id, adapter);
                  setPlayerAdapters((prev) => new Map(prev.set(player.id, adapter)));

                  // Update global controls with first successful player's info
                  if (i === 0) {
                    const totalFrames = adapter.getTotalFrames();
                    const duration = adapter.getDuration();
                    if (totalFrames > 0) {
                      send({
                        type: 'UPDATE_GLOBAL_CONTROLS',
                        totalFrames,
                        duration,
                      });
                    }
                  }

                  console.log(`Successfully recreated player ${player.id}`);
                } else {
                  console.log(`File changed while creating player ${player.id}, cleaning up`);
                  adapter.destroy();
                }
              } catch (error) {
                console.error(`Failed to recreate player ${player.id}:`, error);
                setPlayerStatuses((prev) => new Map(prev.set(player.id, 'error')));
              }
            }
          }
        };

        // Execute recreation asynchronously
        recreatePlayersForNewFile().catch((error) => {
          console.error('Error during player recreation:', error);
        });
      }
    }

    // Update the ref when selectedFile changes
    if (context.selectedFile) {
      prevSelectedFileRef.current = context.selectedFile;
    }
  }, [context.selectedFile, context.players, playerManager, getSyncService, send]);

  return (
    <ErrorBoundary>
      <div className="h-screen bg-gray-50 flex flex-col overflow-hidden">
        {/* Header */}
        <header className="bg-white border-b border-gray-200 px-4 py-2">
          <div className="flex items-center justify-between">
            <h1 className="text-lg font-semibold text-gray-900">Multi-player test</h1>
            <div className="text-xs text-gray-500 space-y-1">
              <div>{context.selectedFile?.name || 'No file selected'}</div>
              {initializationStats.attempts > 0 && (
                <div className="text-xs text-gray-400">
                  Init: {initializationStats.successes}/{initializationStats.attempts}(
                  {Math.round((initializationStats.successes / initializationStats.attempts) * 100)}
                  % success)
                </div>
              )}
            </div>
          </div>
        </header>

        {/* Main Content */}
        <main className="flex-1 w-full p-2 overflow-hidden">
          <div className="h-full flex gap-2">
            {/* Compact Left Sidebar */}
            <div className="w-64 flex-shrink-0 space-y-4 overflow-y-auto">
              {/* File Upload */}
              <div>
                <h2 className="text-sm font-medium text-gray-900 mb-2">Files</h2>
                <FileUpload onFilesSelected={handleFilesSelected} multiple accept=".lottie" />
              </div>

              {/* File List */}
              <FileList
                files={context.files}
                selectedFile={context.selectedFile}
                onSelectFile={handleSelectFile}
                onRemoveFile={handleRemoveFile}
              />
            </div>

            {/* Main Content Area - Takes remaining space */}
            <div className="flex-1 h-full overflow-auto">
              <PlayerGrid
                players={context.players}
                selectedFile={context.selectedFile}
                globalSyncEnabled={context.globalControls.synchronizationMode === 'global'}
                currentFrame={context.globalControls.currentFrame}
                totalFrames={context.globalControls.totalFrames}
                isPlaying={context.globalControls.isPlaying}
                speed={context.globalControls.speed}
                loop={context.globalControls.loop}
                globalZoom={globalZoom}
                onAddPlayer={handleAddPlayer}
                onRemovePlayer={handleRemovePlayer}
                onPlayerReady={(playerId) => console.log(`Player ${playerId} ready`)}
                onPlayerError={(playerId, error) => {
                  console.error(`Player ${playerId} error:`, error);
                  send({ type: 'CLEAR_ERROR' });
                }}
                onIndividualControl={handleIndividualControl}
              />
            </div>
          </div>

          {/* Error Display */}
          {context.error && (
            <div className="fixed bottom-20 right-4 max-w-md z-50">
              <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg shadow-lg">
                <div className="flex items-center justify-between">
                  <span className="text-sm">{context.error}</span>
                  <button
                    onClick={() => send({ type: 'CLEAR_ERROR' })}
                    className="ml-4 text-red-700 hover:text-red-900"
                  >
                    <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                      <path
                        fillRule="evenodd"
                        d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                        clipRule="evenodd"
                      />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Drag Active Overlay */}
          {context.dragActive && (
            <div className="fixed inset-0 bg-primary-50 bg-opacity-90 flex items-center justify-center z-50">
              <div className="text-center">
                <svg
                  className="mx-auto w-16 h-16 text-primary-400 mb-4"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                  />
                </svg>
                <p className="text-2xl font-semibold text-primary-700">Drop files here</p>
                <p className="text-primary-600 mt-2">Release to upload your Lottie files</p>
              </div>
            </div>
          )}
        </main>

        {/* Bottom Control Bar */}
        <BottomControlBar
          playerCount={context.players.length}
          onPlayerCountChange={handlePlayerCountChange}
          globalControls={context.globalControls}
          onGlobalPlay={handleGlobalPlay}
          onGlobalPause={handleGlobalPause}
          onGlobalStop={handleGlobalStop}
          onGlobalSeek={handleGlobalSeek}
          onGlobalSpeedChange={handleGlobalSpeedChange}
          onGlobalLoopToggle={handleGlobalLoopToggle}
          onToggleSyncMode={handleSyncModeToggle}
          onGlobalZoomChange={handleGlobalZoomChange}
          currentFrame={context.globalControls.currentFrame}
          totalFrames={context.globalControls.totalFrames}
          globalZoom={globalZoom}
          className="sticky bottom-0 z-40"
        />
      </div>
    </ErrorBoundary>
  );
}

export default App;
